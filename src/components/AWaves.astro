---
/**
 * AWaves - Sophisticated Perlin Noise Wave Animation
 * Full physics-based cursor interaction
 */
---

<a-waves class="c-waves">
  <svg class="c-waves__svg js-svg"></svg>
</a-waves>

<script>
  import Emitter from '../utils/Emitter'
  import Noise from '../utils/Noise'

  class AWaves extends HTMLElement {
    svg: SVGSVGElement
    lines: any[][]
    paths: SVGPathElement[]
    noise: any
    mouse: {
      x: number
      y: number
      lx: number
      ly: number
      sx: number
      sy: number
      v: number
      vs: number
      a: number
      set: boolean
    }
    bounding: { left: number; top: number; width: number; height: number }
    isInteractive: boolean
    isPaused: boolean

    connectedCallback() {
      this.svg = this.querySelector('.js-svg')!

      this.mouse = {
        x: -10,
        y: 0,
        lx: 0,
        ly: 0,
        sx: 0,
        sy: 0,
        v: 0,
        vs: 0,
        a: 0,
        set: false,
      }

      this.lines = []
      this.paths = []
      this.noise = new Noise(Math.random())
      this.isInteractive = true
      this.isPaused = true

      this.setSize()
      this.setLines()
      this.bindEvents()
    }

    bindEvents() {
      Emitter.on('mousemove', this.onMouseMove, this)
      Emitter.on('resize', this.onResize, this)

      this.addEventListener('touchmove', this.onTouchMove.bind(this), {
        passive: false,
      })

      const el = this.closest('[data-intersect]')
      if (el) {
        el.addEventListener('intersect', this.onIntersect.bind(this), {
          passive: true,
        })
      }

      // Start animation loop
      Emitter.on('tick', this.tick, this)
      this.isPaused = false
    }

    onResize() {
      this.setSize()
      this.setLines()
    }

    onMouseMove(x: number, y: number) {
      this.updateMousePosition(x, y)
    }

    onTouchMove(e: TouchEvent) {
      e.preventDefault()
      const touch = e.touches[0]
      this.updateMousePosition(touch.clientX, touch.clientY)
    }

    updateMousePosition(x: number, y: number) {
      const { mouse } = this

      mouse.x = x - this.bounding.left
      mouse.y = y - this.bounding.top + window.scrollY

      if (!mouse.set) {
        mouse.sx = mouse.x
        mouse.sy = mouse.y
        mouse.lx = mouse.x
        mouse.ly = mouse.y
        mouse.set = true
      }
    }

    onIntersect(e: CustomEvent) {
      this.isPaused = !e.detail.isIntersecting

      if (this.isPaused) {
        Emitter.off('tick', this.tick, this)
      } else {
        Emitter.on('tick', this.tick, this)
      }
    }

    setSize() {
      const bounding = this.getBoundingClientRect()

      this.svg.style.width = ''
      this.svg.style.height = ''

      this.bounding = {
        left: bounding.left,
        top: bounding.top + window.scrollY,
        width: this.clientWidth,
        height: this.clientHeight,
      }

      this.svg.style.width = `${this.bounding.width}px`
      this.svg.style.height = `${this.bounding.height}px`
    }

    setLines() {
      const { width, height } = this.bounding

      this.lines = []
      this.paths.forEach((path) => path.remove())
      this.paths = []

      // Dense grid for premium effect
      const xGap = 10
      const yGap = 22

      const totalLines = Math.ceil((width + 200) / xGap)
      const totalPoints = Math.ceil((height + 50) / yGap)

      const xStart = (width - xGap * totalLines) / 2
      const yStart = (height - yGap * totalPoints) / 2

      for (let i = 0; i <= totalLines; i++) {
        const points: any[] = []

        for (let j = 0; j <= totalPoints; j++) {
          points.push({
            x: xStart + xGap * i,
            y: yStart + yGap * j,
            wave: { x: 0, y: 0 },
            cursor: { x: 0, y: 0, vx: 0, vy: 0 },
          })
        }

        const path = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'path',
        )
        path.classList.add('c-waves__line')
        this.svg.appendChild(path)
        this.paths.push(path)
        this.lines.push(points)
      }

      if (this.isPaused) {
        this.drawLines()
      }
    }

    movePoints(time: number) {
      const { lines, mouse, noise } = this

      lines.forEach((points, lineIndex) => {
        points.forEach((p, pointIndex) => {
          // Perlin noise wave movement - organic flowing motion
          const move =
            noise.perlin2(
              (p.x + time * 0.012) * 0.0025,
              (p.y + time * 0.006) * 0.002,
            ) * 12

          p.wave.x = Math.cos(move) * 32
          p.wave.y = Math.sin(move) * 16

          // Mouse interaction with physics
          if (this.isInteractive) {
            const dx = p.x - mouse.sx
            const dy = p.y - mouse.sy
            const d = Math.hypot(dx, dy)
            const l = Math.max(175, mouse.vs * 1.5)

            if (d < l) {
              const s = 1 - d / l
              const f = Math.cos(d * 0.001) * s

              // Push points away from cursor with velocity
              p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065
              p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065
            }

            // Spring back to original position
            p.cursor.vx += (0 - p.cursor.x) * 0.005
            p.cursor.vy += (0 - p.cursor.y) * 0.005

            // Friction
            p.cursor.vx *= 0.925
            p.cursor.vy *= 0.925

            p.cursor.x += p.cursor.vx * 2
            p.cursor.y += p.cursor.vy * 2

            // Clamp to prevent extreme values
            p.cursor.x = Math.min(100, Math.max(-100, p.cursor.x))
            p.cursor.y = Math.min(100, Math.max(-100, p.cursor.y))
          }
        })
      })
    }

    moved(point: any, withCursor = true) {
      return {
        x:
          Math.round(
            (point.x + point.wave.x + (withCursor ? point.cursor.x : 0)) * 10,
          ) / 10,
        y:
          Math.round(
            (point.y + point.wave.y + (withCursor ? point.cursor.y : 0)) * 10,
          ) / 10,
      }
    }

    drawLines() {
      const { lines, paths } = this

      lines.forEach((points, lIndex) => {
        let p1 = this.moved(points[0], false)
        let d = `M ${p1.x} ${p1.y}`

        points.forEach((point, pIndex) => {
          const isFirst = pIndex === 0
          const isLast = pIndex === points.length - 1
          const p = this.moved(point, !isFirst && !isLast)

          d += ` L ${p.x} ${p.y}`
        })

        paths[lIndex].setAttribute('d', d)
      })
    }

    tick(time: number) {
      if (this.isPaused) return

      const { mouse } = this

      // Smooth mouse follow
      mouse.sx += (mouse.x - mouse.sx) * 0.08
      mouse.sy += (mouse.y - mouse.sy) * 0.08

      // Calculate mouse velocity
      const dx = mouse.x - mouse.lx
      const dy = mouse.y - mouse.ly
      const d = Math.hypot(dx, dy)

      mouse.v = d
      mouse.vs += (d - mouse.vs) * 0.12
      mouse.vs = Math.min(120, mouse.vs)

      mouse.lx = mouse.x
      mouse.ly = mouse.y
      mouse.a = Math.atan2(dy, dx)

      this.movePoints(time)
      this.drawLines()
    }
  }

  customElements.define('a-waves', AWaves)
</script>

<style lang="scss">
  .c-waves {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;

    &__svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    :global(.c-waves__line) {
      fill: none;
      stroke: var(--color-accent);
      stroke-width: 1px;
      opacity: 0.15;
      transition: opacity 0.3s ease;
    }
  }
</style>
